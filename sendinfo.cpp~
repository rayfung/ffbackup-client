#include "sendinfo.h"
#include "commonfunctions.h"
#include "ffbuffer.h"
#include <string>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <openssl/sha.h>
#include <openssl/bio.h>
#include <openssl/err.h>

using namespace std;

send_info::send_info(const char *path, char file_type, unsigned char *md)
{
    int i;
    size_t length = strlen(path);
    this->path = (char *) malloc( sizeof(char) * (length + 1) );
    strcpy(this->path, path);
    this->file_type = file_type;
    if(file_type == 'f')
    {
        for(i = 0; i < SHA_DIGEST_LENGTH; i++)
        {
            this->md[i] = md[i];
        }
    }
}

char* send_info::get_path()
{
    return this->path;
}

char send_info::get_file_type()
{
    return this->file_type;
}

unsigned char* send_info::get_md()
{
    return this->md;
}

scan_dir::scan_dir(const char *dir_path)
{
    size_t length;
    length = strlen(dir_path);
    if(!length)
    {
        this->dir_path = (char *)malloc(sizeof(char) * 2);
        this->dir_path[0] = '.';
        this->dir_path[1] = '\0';
    }
    else
    {
        this->dir_path = (char *)malloc(sizeof(char) * (length + 1));
        strcpy(this->dir_path, dir_path);
    }
}

void scan_dir::sha1(const char* path, unsigned char *md)
{
    int pf = open(path,O_RDONLY);
    if(pf == -1)
    {
        fputs("File can not be open.\n",stderr);
        exit(1);
    }
    const size_t buffer_size = 2048;
    ssize_t ret;
    unsigned char data[buffer_size];
    SHA_CTX ctx;
    if(SHA1_Init(&ctx) == 0)
    {
        fputs("SHA1_Init error.\n",stderr);
        exit(1);
    }
    while( (ret = read(pf, data, buffer_size)) > 0)
    {
        if(SHA1_Update(&ctx,data,ret) == 0)
        {
            fputs("SHA1_Update error.\n",stderr);
            exit(1);
        }
    }
    if(SHA1_Final(md, &ctx) == 0)
    {
        fputs("SHA1_Final error.\n",stderr);
        exit(1);
    }
    return ;   
}

void scan_dir::scan_the_dir(const char *dir, int parent_index)
{
    DIR *dp;
    struct dirent *entry;
    struct stat statbuf;
    unsigned char md[SHA_DIGEST_LENGTH];
    if((dp = opendir(dir)) == NULL || chdir(dir) < 0)
    {
        if(parent_index == -1)
            fputs("Can not scan the director.\n",stderr);
        return ;
    }
    while((entry = readdir(dp)) != NULL)
    {
        lstat(entry->d_name, &statbuf);
        if(S_ISDIR(statbuf.st_mode))
        {
            if(strcmp(".",entry->d_name) == 0 || strcmp("..",entry->d_name) == 0)
                continue;
            string name;
            if(parent_index != -1)
            {
                name = send_list.at(parent_index).get_path();
                name += "/";
            }
            name += entry->d_name;
            send_info to_store(name.c_str(),'d',md);
            send_list.push_back(to_store);
			printf("dir name:%s\n",name.c_str());
            scan_the_dir(entry->d_name, send_list.size() - 1);
        }
        else
        {
            sha1(entry->d_name,md);
            string name;
            if(parent_index != -1)
            {
                name = send_list.at(parent_index).get_path();
                name += "/";
            }
            name += entry->d_name;
            send_info to_store(name.c_str(),'f',md);
			printf("file name:%s\n",name.c_str());
            send_list.push_back(to_store);
        }
    }
    if(chdir("..") == -1)
    {
		fputs("Chdir error.\n",stderr);
		exit(1);
    }
    closedir(dp);
}

void scan_dir::send_file_list(SSL *ssl)
{
	int ret;
    char buf[2];
    char *send_buffer;
    ffbuffer buffer_to_send;
    size_t send_buffer_length = 0;
    size_t get_result = 0;

	
    uint32_t count = send_list.size();

	printf("1.:%d\n",send_list.size());
    int i;
    char version = 1;
    char command = 0x01;
    char *project_path = "/home/william/BackupFiles";
	
	//read_item(dir_path,"Path");
    char *project_name = "Hello";
	//read_item(dir_path,"Project");
    
	dump_data(&count,4);
	printf("\n");
	printf("2.:%d\n",send_list.size());
    count = hton32(count);
    buffer_to_send.push_back(&version,1);
    buffer_to_send.push_back(&command,1);
    buffer_to_send.push_back(project_name,strlen(project_name));
    buffer_to_send.push_back("\0",1);
    buffer_to_send.push_back(&count,4);
	dump_data(&count,4);
	printf("\n");

    send_buffer_length = buffer_to_send.get_size();
    send_buffer = (char *)malloc(send_buffer_length * sizeof(char));
    get_result = buffer_to_send.get(send_buffer, 0, send_buffer_length);
    if(get_result != send_buffer_length)
    {
        fputs("ffbuffer get error.\n",stderr);
        exit(1);
    }
    SSL_write(ssl, send_buffer, get_result);
    buffer_to_send.clear();
    free(send_buffer);
    for(i = 0; i < send_list.size(); i++)
    {
        SSL_write(ssl,send_list.at(i).get_path(),(strlen(send_list.at(i).get_path()) + 1));
        if(send_list.at(i).get_file_type() == 'f')
        {
            SSL_write(ssl,"f",1);
            SSL_write(ssl,send_list.at(i).get_md(),SHA_DIGEST_LENGTH);
        }
        else
            SSL_write(ssl,"d",1);
    }
	printf("Client_start_backup finished.\n");
	printf("Client is waiting for the first response.\n");
	ret = SSL_read(ssl,buf,2);;
        switch( ret = SSL_get_error( ssl, ret ) )
        {
            case SSL_ERROR_NONE:
                printf("right.\n");
                break;
			//case SSL_ERROR_ZERO_RETURN:
            case SSL_ERROR_WANT_READ:
            case SSL_ERROR_WANT_WRITE:
			//case SSL_ERROR_WANT_X509_LOOKUP:
				printf("something wrong.\n");
                return;
			//case SSL_ERROR_SYSCALL:
            default:
				perror("SSL");
                printf("default error:%d\n",ret);
				printf("%s\n",ERR_error_string(ret,NULL));
                return;
        }
    
	printf("start_backup version:%02x\n",(int)buf[0]);
	printf("start_backup command:%02x\n",(int)buf[1]);
}
